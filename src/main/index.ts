/* eslint @typescript-eslint/no-var-requires: "off" */
import { app, BrowserWindow, ipcMain } from 'electron'
import pLimit from 'p-limit'
import path from 'path'
import { updateElectronApp } from 'update-electron-app'
import { getVacancies, getVacancySkills } from './stats'
updateElectronApp()

// This allows TypeScript to pick up the magic constants that's auto-generated by Forge's Webpack
// plugin that tells the Electron app where to look for the Webpack-bundled app code (depending on
// whether you're running in development or production).
declare const MAIN_WINDOW_WEBPACK_ENTRY: string
declare const MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY: string

interface IStats {
  [key: string]: number
}

// Handle creating/removing shortcuts on Windows when installing/uninstalling.
if (require('electron-squirrel-startup')) {
  app.quit()
}

const isDev = !app.isPackaged

let setProgress: (value: number) => void
let reloadWin: () => void
let flash: () => void

const createWindow = (): void => {
  // Create the browser window.
  const mainWindow = new BrowserWindow({
    width: 800,
    height: 600,
    icon: path.join(__dirname, 'icon.ico'),
    webPreferences: {
      preload: MAIN_WINDOW_PRELOAD_WEBPACK_ENTRY,
      devTools: isDev,
    },
  })

  mainWindow.setMinimumSize(600, 400)

  setProgress = (value: number) => {
    mainWindow.setProgressBar(value)
  }

  reloadWin = () => {
    mainWindow.reload()
  }

  flash = () => {
    if (process.platform !== 'darwin') {
      if (!mainWindow.isFocused()) {
        mainWindow.flashFrame(true)
        mainWindow.once('focus', () => mainWindow.flashFrame(false))
      }
    } else {
      app.dock.bounce('informational')
    }
  }

  if (process.platform !== 'darwin') {
    mainWindow.removeMenu()
  }

  // and load the index.html of the app.
  mainWindow.loadURL(MAIN_WINDOW_WEBPACK_ENTRY)

  // Open the DevTools.
  mainWindow.webContents.openDevTools()
}

// This method will be called when Electron has finished
// initialization and is ready to create browser windows.
// Some APIs can only be used after this event occurs.
app.on('ready', () => {
  if (isDev) {
    const devToolsExt = require('electron-devtools-installer')

    devToolsExt
      .default([devToolsExt.REACT_DEVELOPER_TOOLS, devToolsExt.REDUX_DEVTOOLS])
      .then((name: string[]) => {
        console.log(`Added Extensions:  ${name}`)
        setTimeout(() => reloadWin(), 1500)
      })
      .catch((err: string) => console.log('An error occurred: ', err))
  }

  ipcMain.handle('stats', async (e, searchQuery) => {
    setProgress(2)
    let stats: IStats = {}
    console.log(searchQuery)
    const data = await getVacancies(
      searchQuery,
      113,
      0,
      process.env.ELECTRON_WEBPACK_APP_MAIL,
      process.env.ELECTRON_WEBPACK_APP_ACCESS_TOKEN
    )

    const pages = data.pages
    let found = data.found
    console.log(`Pages to be considered: ${pages}`)

    // limitations of hh.ru api
    if (found > 2000) {
      found = 2000
    }

    console.log(`Vacancies to be considered: ${found}`)

    const stepsAmount = found + pages
    let currentStep = 0

    const clusters = []

    const limit = pLimit(4)
    let input = []

    for (let page = 0; page < pages; page++) {
      input.push(
        limit(() =>
          getVacancies(
            searchQuery,
            113,
            page,
            process.env.ELECTRON_WEBPACK_APP_MAIL,
            process.env.ELECTRON_WEBPACK_APP_ACCESS_TOKEN
          ).then((res) => {
            currentStep += 1
            if (currentStep / stepsAmount >= 0.01) {
              setProgress(currentStep / stepsAmount)
            }
            return res
          })
        )
      )
    }

    let results = await Promise.all(input)
    for (const result of results) {
      clusters.push(result.items)
    }

    input = []

    for (const vacancies of clusters) {
      for (const vacancy of vacancies) {
        const id = vacancy.id
        input.push(
          limit(() =>
            getVacancySkills(
              id,
              process.env.ELECTRON_WEBPACK_APP_MAIL,
              process.env.ELECTRON_WEBPACK_APP_ACCESS_TOKEN
            ).then((res) => {
              currentStep += 1
              setProgress(currentStep / stepsAmount)
              return res
            })
          )
        )
      }
    }

    results = await Promise.all(input)

    for (const skills of results) {
      if (skills) {
        for (const skill of skills) {
          if (skill in stats) {
            stats[skill] += 1
          } else {
            stats[skill] = 1
          }
        }
      }
    }

    stats = Object.fromEntries(
      Object.entries(stats).sort((a, b) => b[1] - a[1])
    )
    // console.log(stats)
    setProgress(0)
    flash()
    return stats
  })
  createWindow()
})

// Quit when all windows are closed, except on macOS. There, it's common
// for applications and their menu bar to stay active until the user quits
// explicitly with Cmd + Q.
app.on('window-all-closed', () => {
  if (process.platform !== 'darwin') {
    app.quit()
  }
})

app.on('activate', () => {
  // On OS X it's common to re-create a window in the app when the
  // dock icon is clicked and there are no other windows open.
  if (BrowserWindow.getAllWindows().length === 0) {
    createWindow()
  }
})
